---
title: "Selecting the Right AI Model"
date: 2025-11-13T10:00:00
slug: selecting-the-right-ai-model
authors: [lkgarcia]
tags: [banking, ai, agentic-ai, model, llm, slm, nlm]
prompt: |
  Title: Selecting the Right AI Model: A Framework for Building Reliable and Scalable Agentic Systems

  Message: Effective model selection in agentic AI for retail banking requires a disciplined framework that balances capability, adaptability, cost, latency, risk, and governance. This paper provides a decision model for choosing among Large Language Models (LLMs), Small Language Models (SLMs), Narrow / Specialized Models (NLMs), and adaptation strategies (prompt-only, retrieval augmentation, fine-tuning, multi-modal integration) to build reliable, scalable agent systems.

  Purpose: Deliver an actionable, evidence-based framework to guide architects and product leaders in selecting and adapting language and multi-modal models for high-impact retail banking use cases (e.g., personalized financial guidance, fraud signal triage, customer service orchestration) while controlling cost and risk.

  Goals:
    - Define classification taxonomy: LLM vs SLM vs NLM (capability, cost, latency, governance trade-offs).
    - Provide criteria for when to use: (a) LLM + context/prompt engineering only, (b) Retrieval-Augmented Generation (RAG), (c) Fine-tuning, (d) Multi-modal models.
    - Quantify cost & effort dimensions of fine-tuning (data acquisition, cleaning, annotation, infra, evaluation, ongoing drift management).
    - Outline evaluation dimensions: accuracy, hallucination rate, latency, cost per 1K tokens, privacy/compliance surface, operational maturity.
    - Present model selection decision flow (Mermaid diagram) from use case attributes (complexity, domain specificity, data readiness, regulatory sensitivity) to adaptation strategy.
    - Provide pragmatic 3-phase roadmap (short, mid, long-term) for model portfolio evolution in retail banking.
    - Highlight emerging role of multi-modal (text + document imaging, receipts, statements) and constraints.
    - Embed cost optimization levers (model sizing, caching, distillation, tiered routing, selective RAG scopes).

  Audience: Technical product managers, enterprise/solution architects, AI platform leads, and senior banking executives (mixed technical / non-technical). Assumes familiarity with AI concepts but not deep research expertise.

  Tone: Clear, authoritative, pragmatic; moderately technical yet accessible; caveated where speculative; avoids hype and vendor promotion.

  Length & structure:
    - Target: ~1200–1600 words total.
    - Use plain Markdown headings (no bold), concise paragraphs, bullets, and one Mermaid diagram (decision flow).
    - Inline citations with footnotes: [^n] referencing reputable sources (ArXiv papers, Gartner insights, recognized universities/researchers).
    - Minimize jargon; define terms on first use.

  Sections:
    1) Executive summary (100–150 words): Core thesis + decision framework value.
    2) Introduction: Why disciplined model selection matters now (cost pressure, reliability, governance).
    3) Technical fundamentals:
       - Model scale vs capability vs latency (parameters, context window, throughput).
       - Adaptation continuum: prompt engineering → RAG → fine-tuning → multi-modal integration.
       - Evaluation & risk axes (accuracy, hallucination, compliance, cost kinetics, observability).
    4) Topics (deep dive):
       - Taxonomy: LLM vs SLM vs NLM (definition, strengths, limitations, when to choose each).
       - Strategy comparison: LLM + system prompt vs RAG vs Fine-Tuning (decision criteria: domain specificity, update frequency, data volume, risk tolerance).
       - Cost & effort model of fine-tuning (stages, typical resource consumption, breakeven thresholds).
       - Multi-modal models in retail banking (document ingestion, statement understanding, fraud evidence).
       - Cost dimension & optimization (pricing structures, batching, caching, distillation, model routing, guardrail execution costs).
       - Risk & governance (hallucination mitigation, leakage prevention, bias monitoring, auditability).
    5) Recommendations & roadmap:
       - Short-term: Establish evaluation harness, start with SLM or efficient LLM + robust system prompts + guardrails.
       - Mid-term: Introduce RAG over curated, governed internal knowledge base; selective fine-tuning for narrow classification tasks.
       - Long-term: Portfolio optimization (model routing & distillation), multi-modal expansion, continuous cost governance & drift management.
    6) Conclusion: Reinforce disciplined selection + adaptive strategy as foundation for sustainable agentic AI scaling.

  Decision diagram (Mermaid) guidance: Flow from use case inputs (domain specificity, update velocity, required explainability, available labeled data, latency budget, cost constraints) to recommended path (Prompt-only LLM, SLM, RAG, Fine-tune, Multi-modal extension).

  Examples & requirements:
    - 3-point roadmap (short / mid / long).
    - Emphasis on retail banking scenarios; avoid naming specific banks or jurisdictions.
    - No regulatory specifics; keep governance general (privacy, auditability).

  Constraints: Avoid vendor promotion; provide caveats for emerging capabilities; no unrealistic timelines; no unsupported performance claims.

  Sources (target at least 6 distinct footnotes): Mix of ArXiv (model scaling, RAG efficiency), Gartner (enterprise adoption / cost trends), and leading academic institutions (e.g., Stanford, MIT, Oxford) on evaluation, hallucination mitigation, and multi-modal advances.

  Output Format: Single downloadable Markdown file ready for Docusaurus docs pipeline.

---
:::warning WORK IN PROGRESS
:::

# Selecting the Right AI Model: A Framework for Reliable and Scalable Agentic Systems

## Executive Summary

Agentic AI systems in retail banking promise personalized guidance, smarter fraud detection, and improved customer service. Yet choosing the _right_ AI models and adaptation strategies is critical to balance capability with cost, speed, and risk. This paper presents a structured decision framework for model selection. We define a taxonomy of model scales – from Large Language Models (LLMs) to Small Language Models (SLMs) and narrow domain models – and outline criteria for when to use each. We compare prompt engineering versus Retrieval-Augmented Generation (RAG) versus fine-tuning, and discuss emerging multi-modal AI (combining text with images or other inputs). We quantify the often-underestimated costs of fine-tuning (data collection, annotation, infrastructure) and highlight evaluation dimensions like accuracy, latency, hallucination rates, and compliance. Finally, we provide a phased roadmap for adopting and evolving an optimal model portfolio. By following a disciplined selection approach, banking innovators can deploy AI agents that are **reliable, scalable, and cost-effective** – avoiding the pitfalls that cause many AI projects to stall1.

## Introduction

As generative AI moves past the initial hype, banks face pressure to deliver value while controlling costs and risks. Recent surveys predict **at least 30% of enterprise GenAI projects will be abandoned by 2025** due to poor data quality, inadequate risk controls, escalating costs or unclear ROI1. In retail banking – where accuracy and compliance are paramount – blindly deploying the largest model is no longer tenable. **Cost has become as big an AI risk as security or hallucinations**, according to Gartner2. Meanwhile, regulators and customers demand reliable, explainable outcomes. In this context, _model selection_ is not just a technical decision but a strategic one. Choosing an appropriate model (or combination) can mean the difference between an AI assistant that safely streamlines operations versus one that overruns budget or misleads users. This paper argues that a disciplined framework for model selection and adaptation is now essential. By systematically aligning use cases with the right model scale and approach, banks can achieve strong AI capabilities **while maintaining control over latency, cost, and governance**.

## Technical Fundamentals

**Model Scale vs. Capability vs. Latency:** Modern language models range from billions to hundreds of billions of parameters. Generally, **larger models demonstrate broader knowledge and more sophisticated reasoning, but with higher cost and slower responses**. For example, a 70B-parameter model might answer complex queries more accurately than a 7B model, but will incur significantly more latency and expense per query. In one benchmark, moving from a 1B to a 70B model increased inference latency roughly 10× (0.2s to 3s for the same output length) and _per-token costs by over 7×_ under comparable conditions[openreview.net](https://openreview.net/pdf?id=pZFJLsIY2m#:~:text=restricts%20real,1). In other words, scale brings diminishing returns: accuracy does not increase linearly with size3. Smaller models (e.g. 1–15B parameters) can often match larger models on narrow or structured tasks when fine-tuned, and they can deliver responses in tens of milliseconds instead of seconds3. The trade-off is clear – **bigger isn’t always better**; the optimal size depends on task complexity and real-time requirements. Key performance metrics to monitor include time-to-first-token (how quickly the model starts responding), throughput (requests per second it can handle), and memory/compute footprint.

**Adaptation Continuum:** Beyond choosing a base model, architects must decide how to _adapt_ it to the task. Approaches fall along a continuum of effort and flexibility:

*   **Prompt Engineering (Context-Only):** Using carefully crafted prompts, system instructions, and examples to guide a general model’s behavior without changing its weights. This is the fastest to implement – requiring no model training – and works well when a powerful LLM can solve the task with general knowledge and a bit of guidance. However, prompt-only solutions may struggle with highly domain-specific queries or factual accuracy on enterprise data.
    
*   **Retrieval-Augmented Generation (RAG):** Here the model remains frozen, but is supplied with relevant _external context_ at query time (typically via a vector database lookup). RAG allows systems to **inject up-to-date, domain-specific information into the model’s context**, mitigating the model’s knowledge cutoff or limited training data. This can greatly improve factual accuracy and reduce hallucinations4. The trade-off is added complexity: one must maintain a knowledge repository and ensure the retriever finds high-quality context. RAG introduces latency from the retrieval step, but pipelines can be optimized to still meet interactive speeds. Crucially, RAG **improves transparency and verifiability**, since the model’s answers are grounded in retrieved evidence[mdpi.com](https://www.mdpi.com/2504-4990/6/4/116#:~:text=Our%20approach%20leverages%20the%20inherent,possible%2C%20especially%20in%20scenarios%20where)[mdpi.com](https://www.mdpi.com/2504-4990/6/4/116#:~:text=technique%20used%20for%20enhancing%20the,then%20encoded%20into%20a%20vectorised).
    
*   **Fine-Tuning (Domain Adaptation):** Fine-tuning entails training the model on domain-specific examples or instructions so that it _internalizes_ task knowledge. This can yield strong performance on specialized tasks and reduce the need for elaborate prompts at runtime. Techniques range from full model fine-tuning to parameter-efficient methods (e.g. low-rank adapters or LoRA). Fine-tuning an LLM, however, is a non-trivial project – it requires assembling quality training data, running experiments on GPUs, and evaluating carefully. **The costs can be significant**, both in one-time training spend and ongoing maintenance as data or requirements change. We discuss these costs in depth later. Fine-tuning is best reserved for scenarios where high accuracy on a well-defined task justifies the investment, or where data privacy requires an on-prem model that “knows” internal data without retrieval.
    
*   **Multi-Modal Integration:** Many banking use cases involve not just text but documents, forms, images of IDs or checks, audio from calls, etc. Multi-modal models extend language models with vision, speech, or structured data capabilities. For example, a multi-modal AI assistant might analyze a photo of a handwritten check along with a customer’s query. Such models are emerging rapidly – Gartner projects **40% of GenAI solutions will be multimodal by 2027 (up from just 1% in 2023)**5. Adopting multi-modality can unlock richer functionality (e.g. reading financial statements or parsing transaction receipts), but also raises complexity in model selection and deployment. Often it involves combining separate specialized models (which can introduce latency and integration challenges) or using a very large model natively trained on mixed data. We must consider whether multi-modal capability is essential for a given use case, or if simpler pipelines (like extracting text from documents then using an LLM) suffice in the near term.
    

**Evaluation and Risk Axes:** When evaluating model options, it is critical to go beyond raw accuracy on paper. A holistic evaluation should encompass multiple axes6:

*   **Accuracy & Relevance:** Does the model output correct and useful answers for the task? This includes factual accuracy for knowledge queries and numerical accuracy for calculations.
    
*   **Hallucination Rate:** How often does the model “make up” an answer? Hallucination is especially concerning in finance (e.g. fabricating a regulatory requirement or a transaction that never occurred). Techniques like RAG and prompt constraints help here, but measurement is key – e.g. track the percentage of responses containing unverifiable claims.
    
*   **Latency:** Response time under expected load. An otherwise accurate model that takes 10 seconds per query may fail in a live chat context. Set targets (e.g. <2 seconds for customer-facing agents) and test with realistic concurrent usage.
    
*   **Cost per Query:** Roughly, the compute or API expense per 1000 tokens for each model. This can vary by an order of magnitude between model choices (as shown in the earlier example of 1B vs 70B token pricing[openreview.net](https://openreview.net/pdf?id=pZFJLsIY2m#:~:text=restricts%20real,1)). Estimating cost at scale prevents sticker shock once deployed.
    
*   **Privacy and Compliance:** Does using the model introduce data residency or privacy concerns? Smaller on-prem models give more control, whereas third-party LLM APIs might send sensitive data off-site (needing encryption or redaction). Also, assess if the model has mechanisms for auditing its outputs or explaining decisions – important for compliance.
    
*   **Robustness and Bias:** How does the model perform on edge cases or biased inputs? Are there guardrails to prevent toxic or biased outputs? Evaluation should include stress-testing for unacceptable outputs, especially given fairness and ethical expectations in banking.
    
*   **Operational Maturity:** Consider the tooling and community support for the model. Mature models have better monitoring, debuggability, and fine-tuning support. An open-source model might allow internal audit of its weights, whereas a closed API might offer built-in monitoring tools. Ensure you can log interactions and retrain or update the model over time (for example, to handle model drift as language or products evolve).
    

By scoring options across these dimensions, decision-makers can surface trade-offs clearly – for instance, Model A might score highest on accuracy but pose greater compliance overhead, whereas Model B is slightly less accurate but far cheaper and faster.

## Deep Dive Topics

### Taxonomy of Model Options: LLM vs SLM vs NLM

Not all “AI models” are created equal. It’s useful to classify the types of models available:

*   **Large Language Models (LLMs):** These are the big generalists – typically with **tens or hundreds of billions of parameters, trained on massive text corpora**. Examples include GPT-4-class models or PaLM. LLMs excel at open-ended understanding and reasoning. They can follow complex instructions and have extensive world knowledge. For a bank, an LLM could answer a wide range of customer questions or draft detailed reports with minimal task-specific training. However, they come with **significant drawbacks in enterprise settings**: high inference costs, increased latency, and often they run only via cloud APIs (raising data governance concerns). Fine-tuning an LLM on proprietary data is also expensive (often requiring specialist hardware and weeks of effort). As one recent survey noted, LLMs face _“high fine-tuning costs, inference latency, limited edge deployability, and reliability concerns”_ despite their impressive capabilities3. Thus, LLMs are powerful but heavy tools – best reserved for when the use case truly demands top-tier language prowess across broad knowledge.
    
*   **Small/Medium Language Models (SLMs):** There is no hard cutoff, but SLMs typically range from ~100 million up to 6–15 billion parameters. These models are **orders of magnitude more efficient**, often able to run on a single GPU or even CPU with sub-second latency3. Examples include distilled versions of larger models or bespoke smaller architectures. While an SLM may not match an LLM on complex reasoning out-of-the-box, it can perform remarkably well on domain-specific tasks **when fine-tuned or provided relevant context**. In fact, SLMs fine-tuned on a focused dataset can rival or outperform far larger models on that niche (for example, a 7B model fine-tuned on banking FAQs might beat a 70B model that has never seen those). Enterprise teams favor SLMs for **greater control and cost savings**: these models can often be deployed on-premises (addressing data privacy), updated more frequently, and scaled to millions of queries economically. One industry analysis estimates that training cutting-edge LLMs costs over $100M, and even inference pricing from vendors grows steeply with model size, whereas using SLMs can _cut cost-per-query by two orders of magnitude_ in production3. In short, SLMs trade some generality for **speed, affordability, and ease of governance**, which is often a smart trade-off for well-understood banking applications.
    
*   **Narrow or Specialized Models (NLMs):** We use this term to denote models that are **purpose-built for a specific domain or task**. A narrow model could be an LLM or an SLM – size is secondary to specialization. For example, a 20B-parameter model trained exclusively on financial texts, or a refined version of a general model tuned for credit risk assessment, would qualify as a narrow model. These often originate from fine-tuning an existing model on domain data (e.g. tuning an open-source base on a bank’s documents) or from training a model from scratch on targeted data. The strength of NLMs is **precision and relevance**: by focusing on a limited scope, they can achieve high accuracy and use terminology correctly (reducing irrelevant or incorrect outputs for that domain). NLMs also tend to be more efficient for their domain, since they aren’t burdened by knowledge of unrelated topics. The downside is brittleness outside their specialty – a narrow model might fail if asked something slightly out-of-distribution. In practice, many enterprise AI solutions compose multiple narrow models, each tackling a piece of the problem (for example, one model classifies transaction anomalies while another generates customer responses). When we refer to NLMs, think _“small or large, but specifically fine-tuned for our needs.”_ These require effort to build and maintain but can deliver superior results for high-value tasks like fraud detection, where general models may not be as reliable on the nuances.
    

It is worth noting that these categories overlap. A given solution might use an LLM for general reasoning but an SLM for a particular tool-like function. Also, **open-source vs. closed-source** is another consideration orthogonal to size: open models (often SLMs) allow more customization and on-site deployment, whereas API models (often LLMs) might offer cutting-edge performance but with vendor dependency. Organizations should inventory their use cases and identify which category (or combination) fits each scenario – rather than defaulting to one model for all.

### Choosing an Adaptation Strategy: Prompting vs RAG vs Fine-Tuning

Selecting the base model is step one; next comes deciding how that model will incorporate domain knowledge and stay current. We compare three prevalent strategies:

*   **LLM + System Prompt Only:** _When to use:_ If your use case is relatively general (e.g. conversational FAQs, common-sense reasoning) and doesn’t require up-to-the-minute data, you might simply use a strong LLM out-of-the-box. With thoughtful system prompts and maybe a few examples, the model can often handle tasks via zero-shot or few-shot learning. This approach shines for prototypes or when you need to support a wide variety of queries without building a custom pipeline. It minimizes initial effort – no model training needed – but **watch out for hallucinations or knowledge gaps**. For instance, asking a raw LLM about your bank’s latest policies could yield confident _but incorrect_ answers. This strategy also struggles if the model must reliably cite sources or process customer-specific data (like account info). Use prompt-only when the convenience outweighs the risk, and implement guardrails (like pattern-based checks or fallbacks) to handle when the model’s response might be off the mark.
    
*   **Retrieval-Augmented Generation (RAG):** _When to use:_ If the task requires **incorporating proprietary or dynamic information** (e.g. a virtual assistant giving personalized financial advice using a customer’s transaction history, or an AI tool that answers questions about internal banking procedures), RAG is a compelling approach. Rather than trying to encode all that knowledge in the model’s weights via fine-tuning, RAG keeps a **searchable knowledge base** (documents, database entries, etc.). At query time, the system retrieves relevant snippets and prepends them to the model’s prompt. The LLM or SLM then generates an answer _grounded in those snippets_. The benefit is two-fold: your AI’s knowledge is easily updatable (just add or edit documents in the knowledge store) and **factual accuracy improves**, since the model has the sources in front of it. Studies show retrieval can significantly cut down hallucination rates – one analysis found integrating retrieval reduced incorrect statements by 42–68% in tested scenarios4. Moreover, users and auditors can often trace the answer back to a source document, aiding explainability. The downsides include the engineering overhead of maintaining the retrieval system and ensuring data coverage. Also, if the retrieval fails (no relevant document found), the model might still stumble. RAG is ideal when **your domain data is extensive and changes frequently** (e.g. compliance rules, product details) or when answers must cite evidence. Many high-impact banking uses (fraud investigation assistants, research tools for analysts, customer support bots connected to knowledge bases) will benefit from a RAG architecture.
    
*   **Fine-Tuning the Model:** _When to use:_ If the use case is _narrowly defined, high-volume, and critical for accuracy_, and you have quality training data (or can create it), fine-tuning can pay off. Fine-tuning means your model effectively _learns_ the task – for example, classifying loan applications as approved/denied based on historical data, or generating tailored marketing messages in the brand tone. This often yields the **best task performance** because the model parameters are optimized for your specific data. Fine-tuning is also the go-to when the model needs to handle _nuanced outputs or formats_ (like generating SQL queries or regulatory reports) that are hard to reliably get via prompting alone. However, the commitment is substantial: one must gather and label data, invest in training runs, evaluate on validation sets, and possibly repeat this process to adjust to drift (e.g. new regulatory changes requiring model update). **Data availability is usually the deciding factor** – if you don’t have a large, representative dataset for the task, fine-tuning a big model is ill-advised. In such cases, prompt-based or retrieval approaches are safer. Additionally, fine-tuning large models can be very costly and slow (even with techniques like parameter-efficient tuning). An emerging best practice is to fine-tune smaller open-source models for specific tasks, while using a large model for general reasoning or as a fallback. This “hybrid” approach can give the best of both: the fine-tuned NLM for what it’s great at, and an LLM for everything else. We’ll discuss cost considerations next – in short, **fine-tuning is an investment** that should be justified by a clear business case (e.g. expected improvement in accuracy or user experience that outweighs the effort).
    

Finally, note that these strategies aren’t mutually exclusive. For instance, you might fine-tune a model and _also_ use retrieval augmentation with it to inject new facts. Or use prompting and RAG together with an LLM. The art of solution design is picking the minimal complexity approach that meets the requirements. A decision flow diagram can help choose a path (see **Figure 1**).

mermaid

Copy code

`flowchart TD     A([Use Case Attributes]) --> B{High domain specificity?}     B -- "Yes" --> C{Labeled domain data available?}     C -- "Yes" --> C1[Fine-Tune a Specialized Model (NLM or SLM)]     C -- "No" --> C2[RAG: LLM with Retrieval Augmentation]     B -- "No" --> D{High reasoning complexity?}     D -- "Yes" --> D1[Use Large Language Model (LLM) with prompts]     D -- "No" --> E{Strict latency or cost constraints?}     E -- "Yes" --> E1[Use Small/Efficient Model (SLM), possibly fine-tuned]     E -- "No" --> E2[Use LLM (general model)]     C1 --> M{Multi-modal inputs (text + images)?}     C2 --> M     D1 --> M     E1 --> M     E2 --> M     M -- "Yes" --> M1[Incorporate Multi-Modal Model or Vision Module]     M -- "No" --> X([Deploy Solution])`

_Figure 1: Decision flow for model selection._ From top, assess if the problem is domain-specific and whether you have data to fine-tune a custom model. If not, use retrieval to inject domain knowledge into a general model. For general-use cases, decide based on task complexity: simple tasks with tight speed/cost budgets favor smaller models, whereas complex reasoning might require a large model. In all cases, if the use case involves non-text data (e.g. document images), consider a multi-modal extension.

### Cost and Effort of Fine-Tuning

Fine-tuning deserves a closer look because its costs are often _underestimated_. It’s tempting to assume we can just train the model on our data and achieve a magic boost in accuracy. In reality, successful fine-tuning in an enterprise setting entails:

*   **Data Collection and Labeling:** Obtaining a high-quality dataset of task examples is usually the hardest part. In retail banking, this might mean months of historical chat transcripts annotated with correct responses, or thousands of transaction records labeled as fraudulent or not. The labor (often involving domain experts) to create these labels can be very expensive – recent analyses indicate that the **human annotation cost now often exceeds the computational cost of training** large models7. For example, one study found that for state-of-the-art models in 2024, the total spend on human-provided fine-tuning data was about _3× the spend on compute hardware_ for training those models7. This trend is only growing as model training becomes more efficient but quality data remains scarce. In short, be prepared to invest in data as a first-class cost.
    
*   **Compute Infrastructure:** Fine-tuning large models requires robust infrastructure (GPUs or TPUs) and MLOps pipelines. Even with cloud offerings, the **training fees can rack up quickly**. As a ballpark, fine-tuning a 10B+ parameter model on a moderately sized dataset could cost tens of thousands of dollars in cloud compute, not including iteration if you need to experiment with hyperparameters. Smaller models or parameter-efficient methods (like using LoRA adapters or low-bit quantization) can significantly cut this cost, and are recommended unless full model tuning is absolutely necessary. Also consider _opportunity cost_: engineering time to set up and manage these jobs.
    
*   **Evaluation and Validation:** You cannot just fine-tune and deploy blindly, especially in a regulated domain. You need held-out test data and possibly a human evaluation process to ensure the tuned model performs as expected and hasn’t overfit or picked up new biases. This step might involve additional annotation (for test sets or for evaluating outputs for things like bias or compliance issues). Plan time for a rigorous evaluation cycle, including adversarial testing (e.g. does a fine-tuned chatbot hallucinate less, or perhaps more confidently now? Has it forgotten how to handle inputs outside the fine-tuned domain?).
    
*   **Deployment and Monitoring:** Once a fine-tuned model is in production, monitoring is crucial to catch drift or performance regressions. If the model starts making errors as data trends shift (say, new types of fraud emerge), you need a process to collect new data and re-train or fine-tune again. This ongoing maintenance can be significant. Think of a fine-tuned model as a new _software asset_ that requires lifecycle management: versioning, change audits, periodic retraining, etc., especially as **regulations or product definitions change over time**.
    
*   **Risk Mitigation:** Fine-tuning can inadvertently introduce or amplify biases present in the fine-tuning data, or cause the model to become too confident in a narrow area. It may also leak proprietary data if not done carefully (for instance, if internal data is used to fine-tune a model that is then publicly accessible). Governance steps like data anonymization, bias checks, and security reviews of the model are advisable. Unlike prompting or retrieval, where the base model remains unchanged (and often well-tested), a fine-tuned model is unique – its failures are your responsibility. This is manageable with proper processes but is a heavier lift in terms of accountability.
    

When do these costs and efforts become “worth it”? One rule of thumb is to fine-tune only if the expected scale of use and required accuracy of the task will provide a strong return on that investment. For example, if automating a certain decision via a fine-tuned model could save millions of dollars or significantly reduce manual work, and no off-the-shelf model can do it, the investment is justified. Another case is if fine-tuning a smaller open model can drastically reduce reliance on an expensive API model – the breakeven might come after a certain number of queries served. **Banks should quantify these trade-offs**. In some cases, starting with a prompt/RAG approach to validate impact, then upgrading to a fine-tuned model for efficiency at scale, can be a pragmatic path.

It’s also worth noting new techniques that reduce fine-tuning effort: _few-shot fine-tuning_ (using relatively few examples combined with clever prompting), _reward model tuning_ (RLHF) to align outputs, and _modular training_ (like adding a small domain expert model that works alongside the general model). These can lower data or compute requirements. But whichever approach, always include the costs of data, people, and long-term maintenance in your project planning – not just the one-time training bill.

### Multi-Modal Models in Retail Banking

Many transformative banking AI use cases go beyond text. Consider a fraud investigation agent that reviews scanned ID documents and transaction logs, or a virtual financial advisor that can interpret charts and PDFs in addition to chat. Multi-modal AI refers to systems that can process and combine text, images, audio, and even other data like tables.

Today, there are early examples: OCR (optical character recognition) models to read documents, vision-language models (like document question-answering systems) that can take a document image and a query about it, etc. For retail banking, **document understanding is a key area** – from KYC verification documents to bank statements, a lot of information is locked in PDFs or images. Multi-modal models could automatically extract insights from a pile of paperwork or help a customer understand a chart from their spending history.

However, integrating multi-modal capabilities comes with constraints:

*   Multi-modal models (like those combining vision and language) are often large and still experimental. If you need a model that reads images and responds in text, you might be looking at very new research systems (with correspondingly uncertain behavior).
    
*   An alternative is a pipeline: use a dedicated tool for the non-text part (e.g. an OCR engine or an image classifier) and then feed the results into a language model. This can work well (and is currently a common approach) but requires orchestration and can suffer from _latency_ or _error propagation_ between stages.
    
*   There’s also the question of **data** – training a truly integrated multi-modal model for your domain might not be feasible if you don’t have a large corpus of paired image-text data (e.g. thousands of annotated loan application forms). Using a pre-trained multimodal foundation model is possible, but those are typically very large (and often closed-source).
    
*   **Regulatory clarity** on multi-modal outputs is evolving. For instance, if an AI analyses an image of an official ID, what audit trail is needed? Ensuring the visual data is handled with the same care as text data is important (e.g. no retention of images beyond their use, proper encryption, etc.).
    

Given these factors, the emerging recommendation for most in 2025 is to **start leveraging multi-modal AI in a cautious, incremental way**. You might begin by connecting a vision API to an LLM in a limited scope pilot – for example, allow a chatbot to retrieve a relevant figure from a chart image by calling an external vision service. Monitor the value and issues. Over the longer term (next 2–3 years), expect multi-modal foundation models to become more accessible and enterprise-friendly, at which point adopting one platform that natively handles text + documents could yield big advantages (Gartner analysts forecast a rapid rise in such use within five years5). The key is to ensure your architecture is **modular** enough that you can plug in these capabilities when ready – e.g. design your agent to call specialized modules for vision or speech when needed, rather than assuming all input is plain text.

In retail banking specifically, likely early wins for multi-modality will be:

*   **Document ingestion and Q&A:** e.g. an agent that reads a PDF policy document and answers questions about it (combining document OCR and an LLM).
    
*   **Receipt or Invoice Processing:** a system that takes images of receipts or invoices and automatically categorizes expenses or flags discrepancies (useful for personal finance management tools).
    
*   **Visual Fraud Signals:** analyzing things like screenshot evidence of phishing or fake IDs – here a model might need to see an image and describe issues or inconsistencies.
    
*   **Voice-enabled assistants:** integrating speech-to-text for voice banking assistants, though that’s more about modality input/output than model internals (and can often be handled by separate ASR (automatic speech recognition) feeding a language model).
    

Each of these can be approached with a combination of narrow models (for the vision or speech part) and language models. The long-term vision is a unified agent that seamlessly handles any modality. Banks should track progress but not rush to adopt multi-modal models until they are sufficiently robust for the given task, due to the added complexity.

### Cost Optimization Techniques

Optimizing cost is not just about picking a cheaper model; it’s an ongoing discipline in agentic system design. Some tactics to consider:

*   **Right-sizing the Model:** Don’t use a 175B-parameter model if a 7B model suffices for 95% of queries. Use evaluation to determine the smallest model that meets your accuracy requirements. Often, fine-tuning or RAG can allow use of a smaller base model. Also explore distillation – large models’ knowledge can sometimes be distilled into smaller models for deployment, retaining much of the performance at a fraction of the runtime cost.
    
*   **Dynamic Model Routing:** For heterogeneous workloads, you can route requests to different models based on complexity. For example, simple or routine questions go to a small, fast model, whereas only the tricky ones get escalated to a big LLM. Early research prototypes show that such smart routing can dramatically cut average cost while maintaining quality[openreview.net](https://openreview.net/pdf?id=pZFJLsIY2m#:~:text=integrate%20multiple%20components%2C%20often%20LLMs,2%20Instruct%20%281B)[openreview.net](https://openreview.net/pdf?id=pZFJLsIY2m#:~:text=generates%20100%20tokens%20in%200,weighted%20matching%20to). The key is having a reliable way to predict which queries need the “power” of the large model – possibly via confidence scores or a lightweight classifier. As this technique matures, expect it to become a standard part of enterprise AI stacks (some vendors are already exploring cost-based routers).
    
*   **Caching and Reuse:** Many queries in banking are repetitive (think: “What’s my balance?” or “How do I reset my password?”). Caching LLM responses for common queries (where privacy allows) can save cost and improve latency. Even at a finer grain, caching vector retrieval results or intermediate computations can help. Just be cautious to invalidate caches when underlying data changes (e.g. don’t cache a balance for too long). In internal agent use cases (like research assistants), you can cache aggressively since slight staleness might be acceptable.
    
*   **Batching and Concurrency:** If using cloud API models, costs are often linear per call, so combining multiple tasks into one prompt can sometimes save money (if the API pricing is per token and you can utilize more tokens in one go). For instance, processing 10 small requests in a single batch prompt to a model might be cheaper than 10 separate calls – but this depends on the API and context window limits. For self-hosted models, increasing batch size improves throughput and amortizes overhead, up to hardware limits.
    
*   **Monitoring and Usage Governance:** Keep an eye on usage patterns and have budgets or alerts. It’s easy for costs to creep if an agent starts being used more widely or if prompts unintentionally grow in length. One Gartner report warned that if CIOs don’t understand how GenAI costs scale, they could miscalculate budgets by 5-10×2. To avoid surprises, simulate worst-case volumes and track cost per user or per transaction as a KPI. Negotiate with vendors for volume discounts if applicable.
    
*   **Tiered Model Serving:** Consider offering multiple tiers of service: a fast, minimal-cost option (perhaps with limited capabilities) and a premium thorough option using a larger model. For example, an automated email draft might first be generated by a local small model; only if the user requests a more polished version do you call a costly LLM. This “fallback” approach ensures you spend heavy compute only when needed. It pairs well with uncertainty detection – if the small model is unsure or produces low-confidence output, then escalate to the big model.
    
*   **Efficient Implementation:** Low-level optimizations like quantizing model weights (using 8-bit or 4-bit precision) can greatly reduce memory and increase speed with negligible accuracy loss. This is especially valuable for self-hosted models – quantization and pruning might allow you to run an otherwise 20B model on commodity hardware. Similarly, utilize GPU inference optimizations or specialized AI hardware if you have it, to get more throughput per dollar.
    

In summary, treat cost as a design constraint _just like accuracy_. By architecting the system with cost in mind (e.g. modular design, caching, model choice) and continuously monitoring, you can often achieve **an order-of-magnitude cost reduction** without significantly sacrificing quality. In banking, where margins are slim and compliance demands can inflate cost (e.g. needing on-prem solutions), these levers make the difference between a sustainable AI product and one that gets shut down for being too expensive.

### Risk and Governance Considerations

Deploying agentic AI in retail banking requires a robust risk mitigation strategy from day one. Key areas to address include:

*   **Hallucination and Misinformation:** No model is 100% free of hallucination risk. Even with RAG and fine-tuning, there will be cases where the AI produces an incorrect statement confidently. In high-stakes use (like financial advice), this is unacceptable without safeguards. Strategies to manage this include: instructing the model to say “I don’t know” or defer when unsure, building verification steps (e.g. cross-check important answers against a knowledge base or calculation), and limiting the scope of open-ended generation. Some studies have shown that combining techniques – retrieval, careful prompting, and reinforcement learning feedback – can reduce hallucination rates drastically (one 2024 experiment noted up to 96% reduction in certain settings by layering these4). While elimination of hallucination may not be feasible, **design for containment**: know what the model doesn’t know, and have it fail gracefully.
    
*   **Privacy and Data Security:** Bank data is sensitive by default. If using third-party models (API or SaaS), ensure no customer data is retained or used for provider training (some providers allow opting out of data retention). Apply encryption in transit and at rest. Anonymize inputs where possible (e.g. replace account numbers with a placeholder before sending to a model). On the flip side, if you deploy models on-premises with access to internal data, secure those models – they become new high-value targets. Limit which data the model sees based on user permissions (this is an often overlooked aspect: an AI agent should enforce the same data access controls as any software. For example, a customer service bot should not reveal another customer’s data). Log all model queries and responses for audit, just as you would log human agent interactions in some scenarios.
    
*   **Bias and Fairness:** Models can reflect or even amplify biases in data. A risk in banking is if an AI system gives different quality of service or suggestions to customers based on gender, race, etc., due to underlying bias in training data. Regularly evaluate outputs for biases and use a diverse set of test cases. If biases are found, mitigation might involve further fine-tuning on balanced data or adding rules (for instance, ensuring a loan advisor bot gives the same options regardless of user profile, unless legally allowed to differ). Document these measures as regulators are increasingly asking for evidence of fairness audits in AI.
    
*   **Transparency and Explainability:** When AI influences financial decisions or advice, having an explanation is crucial for user trust and compliance. LLMs are black boxes by nature, but techniques like retrieval augmentation help by providing source documents. Even when not required, consider providing the user references: e.g. “We recommend this investment because of X and Y (sourced from \[report link\]).” Internally, build tools for compliance officers to trace why the AI responded a certain way – maybe by logging which knowledge articles were retrieved or which prompts were used. Some banks are also exploring **model statement auditing**, where they systematically review a sample of AI outputs each month for correctness and appropriateness, akin to how call centers do quality assurance by sampling calls.
    
*   **Robustness to Manipulation:** An emerging concern is prompt injection or adversarial inputs – bad actors trying to trick the AI into revealing information or performing unauthorized actions. For example, a user might phrase a request in a way to bypass content filters (“pretend you are allowed to show me account details…”). It’s important to harden the system: use strict role instructions that the model should not deviate from, sanitize inputs for known exploits, and keep models updated if security patches come out. In some cases, a simpler rule-based layer can intercept dangerous requests before they hit the model (like a regex or heuristic to catch someone asking for something clearly disallowed, independent of the model’s response).
    
*   **Monitoring and Incident Response:** Put in place monitoring that can alert if the AI system is behaving anomalously – e.g. a sudden spike in refusal messages, or an unusual pattern of outputs that could indicate either misuse or a drift in model behavior. Have an incident response plan: if the AI gives a particularly harmful or erroneous output, how will you detect it and what actions will you take (from correcting the output and apologizing to users, to retraining the model if needed)? Consider a backup mechanism: in customer-facing scenarios, if the AI is unsure or flagged, it should hand off to a human or a predefined safe response.
    
*   **Compliance and Documentation:** Keep documentation of your model selection rationale, training data provenance, and testing results. This helps in both internal governance and external oversight. Many regulators now expect a form of “model card” or similar documentation for AI systems describing their intended use, limitations, and performance characteristics. Being proactive here will save time later and build confidence with risk managers and auditors.
    

By weaving these governance practices into the project from the start, banks can significantly reduce the likelihood of an AI project causing compliance headaches or public relation issues. The goal is to harness the benefits of agentic AI **without** stumbling into the known pitfalls – many of which can be anticipated and managed with the right precautions.

## Recommendations & Roadmap

Adopting agentic AI in a bank is a journey. We propose a three-phase roadmap to iteratively build a robust model portfolio and capability:

**Short-term (next 3–6 months):** Focus on _experimentation and establishing guardrails_. Stand up an evaluation harness to benchmark different models on your key tasks (e.g. answer accuracy on a set of banking queries, latency under load tests, etc.). Start with smaller or readily available models to solve low-hanging fruits – for instance, deploy a **small/medium language model with strong prompt instructions** for a pilot like an FAQ chatbot, where responses are limited and can be manually verified initially. Implement basic guardrails such as content filtering and fallback to human agents for unhandled queries. The emphasis in this phase is **control and understanding**: get a sense of model behavior, gather feedback, and ensure you have monitoring in place. Also, this is the time to address data preparation for future steps (e.g. begin curating a knowledge base for RAG, start collecting training examples from interactions). By the end of this phase, you should have confidence in evaluating AI outputs and a clear idea of where the model meets or falls short of requirements.

**Mid-term (6–18 months):** Gradually _increase sophistication while managing risk_. Based on early results, consider introducing **Retrieval-Augmented Generation** on a carefully curated internal knowledge base. For example, connect your chatbot or agent to a secure index of policy documents, product details, and guidelines, so it can provide up-to-date, compliant answers. This will likely improve accuracy and reduce hallucinations, but will require effort to build and govern the knowledge repository (ensure documents are approved and kept current). In parallel, identify narrow tasks that would benefit from **selective fine-tuning**. A good candidate might be a classification or routing task (like triaging fraud alerts or categorizing customer requests) where you have lots of labeled examples – a fine-tuned SLM could excel here and operate with low latency. Introduce such fine-tuned models as specialized components in your system (for instance, the fine-tuned model handles the classification and then hands off to an LLM for explanation). During this phase, also work on **integrating evaluation into regular operations**: for example, monthly metrics on accuracy and cost, and a review process for any incidents. The mid-term goal is to achieve **measurable improvements in performance** (more accurate answers, faster responses, reduced manual work) on key use cases, while still keeping a human in the loop for oversight on any critical decisions.

**Long-term (18+ months, ongoing):** Evolve towards a _portfolio of models and continuous optimization_. By this stage, you likely have multiple AI components – perhaps a large general model, a few fine-tuned specialist models, and a retrieval system, all orchestrated. Now focus on **portfolio optimization**: implement dynamic routing so that each query is handled by the most efficient model that can do the job (as discussed in cost optimization). This might involve developing a meta-controller that evaluates input complexity and chooses between a fast path or a slow path. Also consider model **distillation or compression** efforts: if your usage of a large model is high, investigate creating a distilled version or using techniques to run it cheaper (quantization, compilers, etc.). **Multi-modal expansion** can also come into play – start adding capabilities for images or other data if those use cases have proven value, possibly by incorporating new foundation models that support those modalities (which by then may be more mature). Simultaneously, institutionalize the **governance processes**: periodic re-training to combat drift, bias audits, cost audits, and an AI governance board review for new use cases. The long-term phase is about scaling the solution in a sustainable way: more use cases onboarded, broader acceptance by staff and customers, and tight integration with business workflows. Essentially, AI agents become a normal part of operations, with a robust infrastructure ensuring they remain **accurate, compliant, and cost-effective over time**.

Throughout all phases, maintain a pragmatic outlook. The field will continue to evolve quickly – new models or techniques (perhaps better at reasoning or offering transparency) will emerge. Be ready to pilot those, but do so within the framework of your decision model: assess their true added value against the criteria of capability, cost, and risk. Avoid chasing hype; instead, let the **measured improvements on your KPIs guide adoption**. By following the above roadmap, an organization can steadily increase its AI sophistication while controlling risks, rather than a big-bang approach that might fail to deliver lasting value.

## Conclusion

In the rush to embrace AI, it’s easy to grab whatever powerful model is available and bolt it onto a problem. This paper argues for a more disciplined, framework-driven approach – especially in a sensitive domain like retail banking. **Selecting the right AI model (or combination of models) is foundational to building reliable and scalable agentic systems.** We’ve outlined how to break down this selection: understand the taxonomy of model types and their trade-offs, choose an adaptation strategy aligned with your data and needs, and rigorously evaluate on multiple axes beyond just accuracy.

By applying this framework, architects and product leaders can make evidence-based decisions instead of guesswork. For example, they might recognize that a fine-tuned small model with retrieval augmentation offers the best balance for a given use case – providing accuracy with low latency and cost – whereas another task truly needs a cutting-edge LLM and justifies its expense. The decision flow and criteria we presented help navigate these choices systematically, ensuring factors like domain specificity, data availability, latency requirements, and compliance are all weighed.

Ultimately, building sustainable AI agents is an **iterative journey of adaptation**. Start with straightforward solutions and add complexity only as needed. Use the short/mid/long-term roadmap to gradually layer capabilities, all the while monitoring outcomes. And remain flexible: as new techniques (perhaps better multi-modal models or safer training methods) become available, incorporate them if they fit your framework and improve the goals of capability, cost, or risk.

Banking has long been a data-driven industry, and the promise of agentic AI is immense – from democratizing financial knowledge for customers to augmenting employees with intelligent assistants. Realizing this promise at scale will require not just clever models, but **wise model selection and governance**. By treating model choice as a strategic decision and continuously aligning it with use case needs, organizations can harness AI’s power responsibly. In doing so, they set the stage for AI systems that deliver high impact _and_ high trust – a combination that will define the winners in the next era of digital banking.

## Footnotes

1.  Gartner Press Release (July 29, 2024). _"30% of Generative AI Projects Will Be Abandoned After Proof of Concept by End of 2025."_ Gartner cites poor data quality, inadequate risk controls, rising costs and unclear value as top reasons for failure[gartner.com](https://www.gartner.com/en/newsroom/press-releases/2024-07-29-gartner-predicts-30-percent-of-generative-ai-projects-will-be-abandoned-after-proof-of-concept-by-end-of-2025#:~:text=At%20least%2030,value%2C%20according%20to%20Gartner%2C%20Inc). ↩ ↩2
    
2.  Gartner Press Release (Oct 21, 2024). _"Four Emerging Challenges to Delivering Value from AI Safely and at Scale."_ A survey of CIOs found over 90% concerned with AI costs; Gartner notes _“cost is as big an AI risk as security or hallucinations.”_[gartner.com](https://www.gartner.com/en/newsroom/press-releases/2024-10-21-gartner-identifies-four-emerging-challenges-to-delivering-value-from-ai-safely-and-at-scale#:~:text=The%20Cost%20of%20AI%20Can,risk%20as%20security%20or%20hallucinations) ↩ ↩2
    
3.  F. Wang et al. (2025). _A Survey on Collaborating Small and Large Language Models._ (arXiv 2510.13890). Highlights that while LLMs have advanced capabilities, they incur high fine-tuning and inference costs and latency, whereas SLMs offer efficiency and edge deployability[arxiv.org](https://www.arxiv.org/abs/2510.13890#:~:text=,a%20systematic%20survey%20of%20SLM). Industry data suggests training frontier LLMs can exceed $100M, and inference cost-per-query can be 100× higher than for smaller models[labelyourdata.com](https://labelyourdata.com/articles/llm-fine-tuning/slm-vs-llm#:~:text=5,million%20queries%20by%20over%20100x). ↩ ↩2 ↩3 ↩4 ↩5
    
4.  A. Bora & H. Cuayáhuitl (2024). _“Systematic Analysis of RAG-Based LLMs for Medical Chatbots.”_ (Machine Learning & Knowledge Extraction). Demonstrates that Retrieval-Augmented Generation improves factual accuracy and reduces hallucinations: _“RAG effectively reduces the problem of generating factually incorrect content.”_[mdpi.com](https://www.mdpi.com/2504-4990/6/4/116#:~:text=technique%20used%20for%20enhancing%20the,then%20encoded%20into%20a%20vectorised) Also notes combining RAG with fine-tuning yielded best results in domain QA tasks[mdpi.com](https://www.mdpi.com/2504-4990/6/4/116#:~:text=,are%20key%20for%20best%20results). ↩ ↩2 ↩3
    
5.  Gartner Press Release (Sept 9, 2024). _"40% of GenAI Solutions Will Be Multimodal by 2027."_ Predicts a rapid shift towards multi-modal AI (text, image, audio) in the next few years[gartner.com](https://www.gartner.com/en/newsroom/press-releases/2024-09-09-gartner-predicts-40-percent-of-generative-ai-solutions-will-be-multimodal-by-2027#:~:text=9), from a baseline of only 1% in 2023. Highlights that native multimodal training will unlock new AI capabilities across industries. ↩ ↩2
    
6.  R. Bommasani, P. Liang _et al._ (2023). _Holistic Evaluation of Language Models (HELM)._ Presents a multi-metric evaluation framework covering accuracy, calibration, robustness, fairness, bias, toxicity, and efficiency for language models[ar5iv.labs.arxiv.org](https://ar5iv.labs.arxiv.org/html/2211.09110#:~:text=potential%20scenarios%20%28i,models%20and%20metrics%20are%20clearly). Emphasizes looking beyond accuracy to trade-offs across these metrics. ↩
    
7.  Y. Zhu & D. Kang (2025). _“Human Data is (Probably) More Expensive Than Compute for Training Frontier LLMs.”_ Analysis indicating that the expense of human-labeled data for fine-tuning now exceeds marginal compute costs by a factor of ~3.1× for cutting-edge models[medium.com](https://medium.com/@danieldkang/human-data-is-probably-more-expensive-than-compute-for-training-frontier-llms-3c916ef309e4#:~:text=We%20then%20calculate%20the%20sum,art%20AI%20models). Case studies showed data labeling costs outpacing training costs (e.g. $60k in annotations vs $360 compute in one example)[medium.com](https://medium.com/@danieldkang/human-data-is-probably-more-expensive-than-compute-for-training-frontier-llms-3c916ef309e4#:~:text=If%20we%20estimate%20that%20a,marginal%20compute%20cost%20for%20training), underscoring the importance of data in model adaptation efforts. ↩ ↩2